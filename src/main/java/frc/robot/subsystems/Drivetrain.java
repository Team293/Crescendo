// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.lib.util.Conversions;
import frc.lib.util.SwerveConstants;
import frc.robot.SwerveModule;
import frc.robot.classes.Position2D;

import com.ctre.phoenix6.signals.NeutralModeValue;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.Timer;

import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.kinematics.SwerveDriveKinematics;
import edu.wpi.first.math.kinematics.SwerveDriveOdometry;
import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.math.kinematics.SwerveModuleState;

public class Drivetrain extends SubsystemBase {
    public SwerveDriveOdometry m_swerveOdometry;
    public SwerveModule[] m_swerveModules;
    public final AHRS gyro;

    public Drivetrain() {
        gyro = new AHRS(SerialPort.Port.kMXP);
        gyro.reset();
        zeroGyro();

        // Create modules from the constant values in SwerveConstants
        m_swerveModules = new SwerveModule[] {
            new SwerveModule(0, SwerveConstants.Swerve.Mod0.constants),
            new SwerveModule(1, SwerveConstants.Swerve.Mod1.constants),
            new SwerveModule(2, SwerveConstants.Swerve.Mod2.constants),
            new SwerveModule(3, SwerveConstants.Swerve.Mod3.constants)
        };

        // By pausing init for a second before setting module offsets, we avoid a bug with inverting motors
        Timer.delay(1.0);
        resetModulesToAbsolute();

        // Create a new swerve odometry object, similar to the Kinematics.java file before
        m_swerveOdometry = new SwerveDriveOdometry(SwerveConstants.Swerve.swerveKinematics, getYaw(), getModulePositions());
    }

    public void drive(Translation2d translation, double rotationSpeed, boolean fieldRelative, boolean isOpenLoop) {
        SwerveModuleState[] swerveModuleStates =
            SwerveConstants.Swerve.swerveKinematics.toSwerveModuleStates(
                fieldRelative ? ChassisSpeeds.fromFieldRelativeSpeeds(
                                    translation.getX(),
                                    translation.getY(),
                                    rotationSpeed,
                                    getYaw()
                                )
                                : new ChassisSpeeds(
                                    translation.getX(),
                                    translation.getY(),
                                    rotationSpeed)
                                );
        SwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, SwerveConstants.Swerve.maxSpeed);

        for (SwerveModule module : m_swerveModules) {
            module.setDesiredState(swerveModuleStates[module.m_moduleNumber], isOpenLoop);
        }
    }

    public void setNeutralMode(NeutralModeValue nm) {
        for (SwerveModule module : m_swerveModules) {
            module.setNeutralMode(nm);
        }
    }

    @Override
    public void periodic() {
        m_swerveOdometry.update(getYaw(), getModulePositions());

        // Add the current robot position to smartdashboard
        Pose2d robotTranslation = m_swerveOdometry.getPoseMeters();
        SmartDashboard.putNumber("Robot X (SwerveOdometry)", robotTranslation.getTranslation().getX());
        SmartDashboard.putNumber("Robot Y (SwerveOdometry)", robotTranslation.getTranslation().getY());
        SmartDashboard.putNumber("Robot Angle (SwerveOdometry)", robotTranslation.getRotation().getDegrees());

        SmartDashboard.putNumber("Robot Yaw (Z)",  ((gyro.getYaw() % 360.0)));
        SmartDashboard.putNumber("Robot Pitch (X)",  ((gyro.getPitch() % 360.0)));
        SmartDashboard.putNumber("Robot Roll (Y)",  ((gyro.getRoll() % 360.0)));

        SmartDashboard.putNumber("Yaw", getYaw().getDegrees());

        for (SwerveModule module : m_swerveModules) {
            SmartDashboard.putNumber("Mod " + module.m_moduleNumber + " Module (degrees)", module.getAngle().getDegrees() % 360);
            SmartDashboard.putNumber("Mod " + module.m_moduleNumber + " CANcoder (degrees)", module.getCANcoder().getDegrees() % 360);
            SmartDashboard.putNumber("Mod " + module.m_moduleNumber + " Meters/Sec", module.getState().speedMetersPerSecond);
            SmartDashboard.putNumber("Mod " + module.m_moduleNumber + " Target rotations", module.m_targetRotations);
        }
    }

    public void setModuleStates(SwerveModuleState[] desiredStates) {
        SwerveDriveKinematics.desaturateWheelSpeeds(desiredStates, SwerveConstants.Swerve.maxSpeed);

        for (SwerveModule module : m_swerveModules) {
            module.setDesiredState(desiredStates[module.m_moduleNumber], false);
        }
    }

    public Pose2d getPose() {
        return m_swerveOdometry.getPoseMeters();
    }

    public void resetOdometry(Pose2d pose) {
        m_swerveOdometry.resetPosition(getYaw(), getModulePositions(), pose);
    }

    public SwerveModuleState[] getModuleStates() {
        SwerveModuleState[] states = new SwerveModuleState[m_swerveModules.length];
        for (SwerveModule module : m_swerveModules) {
            states[module.m_moduleNumber] = module.getState();
        }

        return states;
    }

    public SwerveModulePosition[] getModulePositions() {
        SwerveModulePosition[] positions = new SwerveModulePosition[m_swerveModules.length];
        for (SwerveModule module : m_swerveModules) {
            positions[module.m_moduleNumber] = module.getPosition();
        }

        return positions;
    }

    public void zeroGyro() {
        gyro.zeroYaw();
    }

    public Rotation2d getYaw() {
        return Rotation2d.fromDegrees(-gyro.getAngle() % 360.0);
    }

    public void resetModulesToAbsolute() {
        for (SwerveModule module : m_swerveModules) {
            module.resetToAbsolute();
        }
    }

    public void initAutonomous(Position2D startingPose) {
        resetOdometry(new Pose2d(startingPose.getX(), startingPose.getY(), new Rotation2d(startingPose.getHeadingRadians())));
    }

    public void stop() {
        drive(new Translation2d(0, 0), 0, true, false);
    }
}
